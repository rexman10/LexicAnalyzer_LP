#Este bloque de codigo es otra opcion, para que los resultados de analisis, de varios errores en token, sean devueltos
#a la funcion analizar_sintactico() de interfaz.py y lo ubique en el recuadro de sintactico
#Se pone al final de todaslas reglas establecidas

#Solo copiar y pegar. Esta opcion esta funcional sin problemas con interfaz.py

mensajes_error = []

def p_error(p):
    if p:
        error_message = "Error de sintaxis en el token: " + str(p.type) + ", línea: " + str(p.lineno)
        error_message += ", columna: " + str(obtener_columna(p.lexpos))
        mensajes_error.append(error_message)
        #Por default solo me analiza el primer error que encuentra, pero con
        #sintactico.errok() se raliza el analisis y devuele mas errores
        sintactico.errok()
    else:
        print("Syntax error at EOF")

def obtener_columna(lexpos):
    # Calcula el número de columna en base a la posición del token
    # en el contenido analizado
    linea_actual = datos.rfind('\n', 0, lexpos) + 1
    return lexpos - linea_actual + 1

# Build the parser
sintactico = yacc.yacc()

datos = '''
using System;
public class clase1 {
    static void Main (string[] args) {
        bool var1 = x >= 34 && x == 34;
        bool var2 = x <= 34 || x == 34;
        bool var3 = x > 34;
        bool var4 = x < 34 && x == 34 && x != 34;
        bool var5 = true;
        bool var6 = false;
        int operacion1 = 123 / 123123 + 5345 * 123124 - 4365;
        int var = 4;
        string var2 = "6" , var3 = "8";
    }
}
'''

def analizar_sintactico(contenido):
    result = sintactico.parse(contenido)
    #return result is not None
    if result!=None:
        return result

analizar_sintactico(datos)

if len(mensajes_error) > 0:
    for error in mensajes_error:
        print(error)
    else:
        print("Análisis sintáctico exitoso")