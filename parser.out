Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADDITION_ASSIGNMENT
    BACK_SLASH
    BOOL
    BREAK
    DECREMENT
    DIVISION_ASSIGNMENT
    DOLLARSIGN
    DOT
    DOTANDCOMMA
    DOUBLEPOINT
    DOUBLE_QUOTATION_MARKS
    ELSE
    FINALLY
    FOR
    IF
    INCREMENT
    JUMP_LINE
    LBRACKET
    LONG
    MODULE_ASSIGNMENT
    MULTIPLICATION_ASSIGNMENT
    NAMESPACE
    NEW
    PIPE
    PRINT
    RBRACKET
    RETURN
    SIPLE_QUOTATION_MARKS
    STATIC
    SUBTRACTION_ASSIGNMENT
    SWITCH
    TABULATION
    VOID
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> block_using block_publicClass
Rule 2     block_using -> USING SYSTEM
Rule 3     block_publicClass -> PUBLIC CLASS VARIABLE LKEY block_code RKEY
Rule 4     data_type -> CHARTYPE
Rule 5     data_type -> STRINGTYPE
Rule 6     data_type -> FLOATTYPE
Rule 7     data_type -> DECIMALTYPE
Rule 8     data_type -> INTTYPE
Rule 9     data_type -> BOOLTYPE
Rule 10    access_modifiers -> PUBLIC
Rule 11    access_modifiers -> PRIVATE
Rule 12    arithmetic_operation -> value_numeric
Rule 13    arithmetic_operation -> value_numeric arithmetic_operator arithmetic_operation
Rule 14    value_numeric -> INTEGER
Rule 15    value_numeric -> FLOAT_NUMBER
Rule 16    value_numeric -> DECIMAL_NUMBER
Rule 17    value_numeric -> VARIABLE
Rule 18    value_logic -> BOOLTRUE
Rule 19    value_logic -> BOOLFALSE
Rule 20    value_logic -> VARIABLE
Rule 21    logic_operation -> value_logic
Rule 22    logic_operation -> value_logic logic_operator logic_operation
Rule 23    concatenation -> STRING
Rule 24    concatenation -> STRING PLUS concatenation
Rule 25    value_string -> STRING
Rule 26    value_string -> CHAR
Rule 27    value_string -> VARIABLE
Rule 28    value_string -> READ LPARENT RPARENT
Rule 29    value_string -> concatenation
Rule 30    value -> value_numeric
Rule 31    value -> value_logic
Rule 32    value -> value_string
Rule 33    logic_operator -> GREATER_THAN
Rule 34    logic_operator -> SMALLER_THAN
Rule 35    logic_operator -> EQUAL_COMPARATION
Rule 36    logic_operator -> INEQUALITY
Rule 37    logic_operator -> GREATER_THAN_OR_EQUAL
Rule 38    logic_operator -> SMALLER_THAN_OR_EQUAL
Rule 39    logic_operator -> LOGICAND
Rule 40    logic_operator -> LOGICOR
Rule 41    logic_operator -> LOGICNOT
Rule 42    logic_operator -> LOGICXOR
Rule 43    arithmetic_operator -> PLUS
Rule 44    arithmetic_operator -> MINUS
Rule 45    arithmetic_operator -> TIMES
Rule 46    arithmetic_operator -> DIVIDE
Rule 47    arithmetic_operator -> PERCENT
Rule 48    constant_assignation -> access_modifiers CONST data_type VARIABLE ASSIGNATION value
Rule 49    constant_assignation -> CONST data_type VARIABLE ASSIGNATION value
Rule 50    variable_assignation_simple -> access_modifiers data_type VARIABLE ASSIGNATION value
Rule 51    variable_assignation_simple -> data_type VARIABLE ASSIGNATION value
Rule 52    variable_assignation_simple -> data_type VARIABLE
Rule 53    variable_assignation_simple -> VARIABLE ASSIGNATION value
Rule 54    variable_multivalue -> variable_assignation_simple
Rule 55    variable_multivalue -> variable_assignation_simple COMMA variable_multivalue
Rule 56    variable_assignation_multiline -> <empty>
Rule 57    block_code -> VARIABLE
Rule 58    block_code -> try_catch_simply
Rule 59    try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

Terminals, with rules where they appear

ADDITION_ASSIGNMENT  : 
ASSIGNATION          : 48 49 50 51 53
BACK_SLASH           : 
BOOL                 : 
BOOLFALSE            : 19
BOOLTRUE             : 18
BOOLTYPE             : 9
BREAK                : 
CATCH                : 59
CHAR                 : 26
CHARTYPE             : 4
CLASS                : 3
COMMA                : 55
CONST                : 48 49
DECIMALTYPE          : 7
DECIMAL_NUMBER       : 16
DECREMENT            : 
DIVIDE               : 46
DIVISION_ASSIGNMENT  : 
DOLLARSIGN           : 
DOT                  : 
DOTANDCOMMA          : 
DOUBLEPOINT          : 
DOUBLE_QUOTATION_MARKS : 
ELSE                 : 
EQUAL_COMPARATION    : 35
EXCEPTION            : 59
FINALLY              : 
FLOATTYPE            : 6
FLOAT_NUMBER         : 15
FOR                  : 
GREATER_THAN         : 33
GREATER_THAN_OR_EQUAL : 37
IF                   : 
INCREMENT            : 
INEQUALITY           : 36
INTEGER              : 14
INTTYPE              : 8
JUMP_LINE            : 
LBRACKET             : 
LKEY                 : 3 59 59
LOGICAND             : 39
LOGICNOT             : 41
LOGICOR              : 40
LOGICXOR             : 42
LONG                 : 
LPARENT              : 28 59
MINUS                : 44
MODULE_ASSIGNMENT    : 
MULTIPLICATION_ASSIGNMENT : 
NAMESPACE            : 
NEW                  : 
PERCENT              : 47
PIPE                 : 
PLUS                 : 24 43
PRINT                : 
PRIVATE              : 11
PUBLIC               : 3 10
RBRACKET             : 
READ                 : 28
RETURN               : 
RKEY                 : 3 59 59
RPARENT              : 28 59
SIPLE_QUOTATION_MARKS : 
SMALLER_THAN         : 34
SMALLER_THAN_OR_EQUAL : 38
STATIC               : 
STRING               : 23 24 25
STRINGTYPE           : 5
SUBTRACTION_ASSIGNMENT : 
SWITCH               : 
SYSTEM               : 2
TABULATION           : 
TIMES                : 45
TRY                  : 59
USING                : 2
VARIABLE             : 3 17 20 27 48 49 50 51 52 53 57 59
VOID                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

access_modifiers     : 48 50
arithmetic_operation : 13
arithmetic_operator  : 13
block_code           : 3 59 59
block_publicClass    : 1
block_using          : 1
concatenation        : 24 29
constant_assignation : 
data_type            : 48 49 50 51 52
logic_operation      : 22
logic_operator       : 22
program              : 0
try_catch_simply     : 58
value                : 48 49 50 51 53
value_logic          : 21 22 31
value_numeric        : 12 13 30
value_string         : 32
variable_assignation_multiline : 
variable_assignation_simple : 54 55
variable_multivalue  : 55

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block_using block_publicClass
    (2) block_using -> . USING SYSTEM

    USING           shift and go to state 3

    program                        shift and go to state 1
    block_using                    shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> block_using . block_publicClass
    (3) block_publicClass -> . PUBLIC CLASS VARIABLE LKEY block_code RKEY

    PUBLIC          shift and go to state 5

    block_publicClass              shift and go to state 4

state 3

    (2) block_using -> USING . SYSTEM

    SYSTEM          shift and go to state 6


state 4

    (1) program -> block_using block_publicClass .

    $end            reduce using rule 1 (program -> block_using block_publicClass .)


state 5

    (3) block_publicClass -> PUBLIC . CLASS VARIABLE LKEY block_code RKEY

    CLASS           shift and go to state 7


state 6

    (2) block_using -> USING SYSTEM .

    PUBLIC          reduce using rule 2 (block_using -> USING SYSTEM .)


state 7

    (3) block_publicClass -> PUBLIC CLASS . VARIABLE LKEY block_code RKEY

    VARIABLE        shift and go to state 8


state 8

    (3) block_publicClass -> PUBLIC CLASS VARIABLE . LKEY block_code RKEY

    LKEY            shift and go to state 9


state 9

    (3) block_publicClass -> PUBLIC CLASS VARIABLE LKEY . block_code RKEY
    (57) block_code -> . VARIABLE
    (58) block_code -> . try_catch_simply
    (59) try_catch_simply -> . TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    VARIABLE        shift and go to state 10
    TRY             shift and go to state 13

    block_code                     shift and go to state 11
    try_catch_simply               shift and go to state 12

state 10

    (57) block_code -> VARIABLE .

    RKEY            reduce using rule 57 (block_code -> VARIABLE .)


state 11

    (3) block_publicClass -> PUBLIC CLASS VARIABLE LKEY block_code . RKEY

    RKEY            shift and go to state 14


state 12

    (58) block_code -> try_catch_simply .

    RKEY            reduce using rule 58 (block_code -> try_catch_simply .)


state 13

    (59) try_catch_simply -> TRY . LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    LKEY            shift and go to state 15


state 14

    (3) block_publicClass -> PUBLIC CLASS VARIABLE LKEY block_code RKEY .

    $end            reduce using rule 3 (block_publicClass -> PUBLIC CLASS VARIABLE LKEY block_code RKEY .)


state 15

    (59) try_catch_simply -> TRY LKEY . block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY
    (57) block_code -> . VARIABLE
    (58) block_code -> . try_catch_simply
    (59) try_catch_simply -> . TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    VARIABLE        shift and go to state 10
    TRY             shift and go to state 13

    block_code                     shift and go to state 16
    try_catch_simply               shift and go to state 12

state 16

    (59) try_catch_simply -> TRY LKEY block_code . RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    RKEY            shift and go to state 17


state 17

    (59) try_catch_simply -> TRY LKEY block_code RKEY . CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    CATCH           shift and go to state 18


state 18

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH . LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    LPARENT         shift and go to state 19


state 19

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT . EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    EXCEPTION       shift and go to state 20


state 20

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION . VARIABLE RPARENT LKEY block_code RKEY

    VARIABLE        shift and go to state 21


state 21

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE . RPARENT LKEY block_code RKEY

    RPARENT         shift and go to state 22


state 22

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT . LKEY block_code RKEY

    LKEY            shift and go to state 23


state 23

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY . block_code RKEY
    (57) block_code -> . VARIABLE
    (58) block_code -> . try_catch_simply
    (59) try_catch_simply -> . TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY

    VARIABLE        shift and go to state 10
    TRY             shift and go to state 13

    block_code                     shift and go to state 24
    try_catch_simply               shift and go to state 12

state 24

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code . RKEY

    RKEY            shift and go to state 25


state 25

    (59) try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY .

    RKEY            reduce using rule 59 (try_catch_simply -> TRY LKEY block_code RKEY CATCH LPARENT EXCEPTION VARIABLE RPARENT LKEY block_code RKEY .)

